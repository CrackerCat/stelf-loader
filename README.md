# stelf-loader
A stealthy ELF loader - no files, no execve, no RWX

See also: [arget13/DDexec](https://github.com/arget13/DDexec), which is a similar idea to this but probably more flexible - I wrote most of `stelf-loader` before I realised that `DDexec` existed!

Here's a simple "hello world" ELF (`test_elfs/syscall-static-pie.c`), packed using stelf-loader:

```sh
$ python3 elf_to_stelf.py test_elfs/syscall-static-pie - -r -o
echo H4sIAPhn+mMC/2VRXW+iQBR951fMZptNG9IMCKIktQmICmhXERBK9gWGGRxE5EsU0h+/1u3Dbva8nJt77rkfud+/wYjmsN4zTIXDGITgBRbVCcEaZwTWXY3CLGPwFSMgvP6lHPERiC8vs/WcibJwz3wGKGwAjHELSQxF8HoP8/PNHoU1lkTwHIO7A3yA5Jz3tPiquZf/YHSxNpTNPmePb1PICsGGazVLTfWxHTezQ+nLqsDFC6nQLUuHHb9U9zGxDodUTZbL6Tt1KkmzYlaNpHkiMeVaS86C2nOrQT8sSuwr9opK6QVa1yHWRwhdsKDjnDjDah8uEKY/r0t74BzpLE1k1Iqlx9NeFAnu3j1mPRzVx4iydC6faTu7KndoYhQjfSsifttDyRb8IHN9f9m2crCVyrTbzRu6Y8e+t+L9slny42gt70pGbrwmgB6RRoVb9kI+aOvCQ4NwzAr8QvbDzDvxqHf7QBxVlSOd67DXe5hbGStX0z+Tlc0Al/o4EBg23VTSgrDhZs1XBMbOCK+qduxhBaKZpfwDwnPvBZsF24E/NGYsHeUHu+wT2Q1ik5TlgulcFw3tctSVpno8BpXjiau709CgtB1YUaqFyvwzMZncH/7/X+MY1E3YnOtJfsoxiOoJD2qMD5OHx8eHR4z2J/AQfqBzczP9AuCZyE9PT+D1h8C8oell6uiwTdTPva9cZWiOo9tWZNAbKzYh1o1N7bIzKYpNSgKDEtOg6P0Kuamgarpy04w9UkVG5hL1ekiKS+6398aHzoRcZ8qpbteJu1FdHQ4vX1f8BpvqjaUDAwAA|base64 -d|gunzip|/bin/sh
```

You could put this in a file and execute it, but that would slightly defeat the
purpose (of being file-less). The intended usage scenario is to paste it directly into a terminal,
or perhaps even `curl | sh` or `nc | sh`. The aim is to be as portable as possible between different shell implementations. So far I've tested it against `bash`, `zsh`, `dash`, and `busybox ash`.

This implementation currently relies on some hand-written x86-64 shellcode, but the
general approach should be applicable cross-architecture.

It works on both `static` and `static-pie` ELFs. However, dynamic ELFs are out of scope for this project.

## Shell-based self-injecting shellcode loader

Using some clever tricks (TODO: explain), we instruct Bash to
load some shellcode into itself, ultimately using `dd` to write to `/proc/self/mem`.
We inject a small fragment of shellcode, which in turn loads a much larger piece
of shellcode. The larger shellcode is generated by...

## `elf_to_shellcode.py`

This is usable as a standalone script. It flattens a static
ELF into a piece of shellcode. This is very similar to what [gamozolabs/elfloader](https://github.com/gamozolabs/elfloader) does,
except it also generates a shellcode stub that sets up the correct page permissions. (If I was rewriting this project today, I'd use `elfloader` to do the ELF parsing, but writing my own was an educational exercise.)
This avoids needing RWX mappings.

## `elf_to_stelf.py`

This script ties together all the aforementioned tricks. It takes a static-pie ELF as input, and outputs a (potentially extremely long) sequence of shell commands.

## TODO

- mmap and pivot to a fresh stack
- add more options to `elf_to_shellcode.py`
